<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hansen</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="hansen_files/libs/clipboard/clipboard.min.js"></script>
<script src="hansen_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="hansen_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="hansen_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="hansen_files/libs/quarto-html/popper.min.js"></script>
<script src="hansen_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="hansen_files/libs/quarto-html/anchor.min.js"></script>
<link href="hansen_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="hansen_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="hansen_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="hansen_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="hansen_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="la-teoría-de-solubilidad-de-hansen-y-sus-aplicaciones-en-la-ingeniería-de-disolventes" class="level1">
<h1>La Teoría de Solubilidad de Hansen y sus Aplicaciones en la Ingeniería de Disolventes</h1>
<section id="introducción-de-la-empiria-a-la-modelización-predictiva" class="level2">
<h2 class="anchored" data-anchor-id="introducción-de-la-empiria-a-la-modelización-predictiva">Introducción: De la Empiria a la Modelización Predictiva</h2>
<p>La selección de disolventes en la industria ha dependido históricamente del principio cualitativo “lo semejante disuelve a lo semejante”. Aunque fundamentalmente correcto, este enfoque empírico exige un extenso y costoso trabajo de laboratorio basado en el ensayo y error. La introducción de los Parámetros de Solubilidad de Hansen (HSP) representó un avance crucial, transformando el proceso hacia un modelo cuantitativo y predictivo que permite anticipar la compatibilidad entre materiales a nivel molecular. El propósito de este informe es desglosar la teoría de Hansen, su marco predictivo y su aplicación estratégica en la formulación industrial, con un enfoque particular en el diseño de disolventes sostenibles de nueva generación. Este análisis comenzará por explorar los fundamentos termodinámicos que sustentan este poderoso modelo.</p>
</section>
<section id="fundamentos-de-la-teoría-de-solubilidad-de-hansen" class="level2">
<h2 class="anchored" data-anchor-id="fundamentos-de-la-teoría-de-solubilidad-de-hansen">Fundamentos de la Teoría de Solubilidad de Hansen</h2>
<p>Para predecir con precisión la solubilidad, es imperativo comprender los componentes energéticos que gobiernan las interacciones intermoleculares. La contribución fundamental de Charles Hansen fue descomponer la energía cohesiva total, una medida macroscópica de las fuerzas que mantienen unido un líquido, en contribuciones específicas y ortogonales. Esta descomposición permite una cuantificación mucho más precisa de la afinidad química entre un soluto y un disolvente en comparación con los modelos unidimensionales que la precedieron.</p>
<p>2.1 Del Parámetro de Hildebrand a los Componentes de Hansen</p>
<p>El origen de la teoría moderna de la solubilidad se encuentra en el concepto de Energía Cohesiva, definida como la energía necesaria para superar todas las fuerzas intermoleculares y vaporizar una sustancia. El primer modelo cuantitativo, el Parámetro de Solubilidad de Hildebrand (δ), se define como la raíz cuadrada de la Densidad de Energía Cohesiva [^belmares2004]. Si bien esta aproximación es efectiva para sistemas no polares donde las interacciones son dominadas por fuerzas dispersivas, su poder predictivo disminuye significativamente en sistemas que involucran interacciones polares o puentes de hidrógeno, ya que agrupa todas las contribuciones energéticas en un único valor.</p>
<p>2.2 Los Tres Parámetros Fundamentales: Dispersión, Polaridad y Puentes de Hidrógeno</p>
<p>La contribución central de Hansen fue proponer que la energía cohesiva total no es monolítica, sino que se puede descomponer en tres componentes que reflejan los tipos fundamentales de fuerzas intermoleculares. Estos tres Parámetros de Solubilidad de Hansen (HSP) son:</p>
<ul>
<li>_D (Dispersión): Representa la energía proveniente de las fuerzas de dispersión de London, originadas por dipolos instantáneos inducidos en las nubes electrónicas de las moléculas. Están presentes en todas las moléculas, independientemente de su polaridad.</li>
<li>_P (Polar): Cuantifica la energía de las interacciones dipolo-dipolo permanentes que ocurren entre moléculas polares.</li>
<li>_H (Puentes de Hidrógeno): Mide la energía de interacciones específicas de tipo donador/aceptor de electrones, como los puentes de hidrógeno.</li>
</ul>
<p>Estos tres parámetros no son meramente aditivos, sino que se relacionan a través de una suma de cuadrados, definiendo el parámetro de solubilidad total de Hansen (δ).</p>
<p>Ecuación Fundamental de Hansen: ^2 = _D^2 + _P^2 + _H^2 [Hansen, 1967; Hansen, 2007]</p>
<p>La siguiente tabla ilustra cómo diferentes materiales presentan balances únicos de estos tres componentes energéticos.</p>
<p>Tabla 1: Parámetros de Solubilidad de Hansen para Materiales Representativos (MPa^{1/2})</p>
<p>Material Clase Química δD δP δH δ_Total Metanol Alcohol 15.1 12.3 22.3 29.6 Benceno Aromático 18.0 0.0 2.0 18.1 Acetona Cetona 15.5 10.4 7.0 19.8 Polietileno (PE) Polímero No Polar 16.2 0.0 0.0 16.2</p>
<p>La potencia del modelo de Hansen reside en cómo estas tres coordenadas construyen un espacio predictivo para cuantificar la afinidad química.</p>
<p>3.0 El Espacio de Hansen y la Predicción Cuantitativa de la Solubilidad</p>
<p>Los tres parámetros de Hansen no son valores aislados, sino coordenadas (δD, δP, δH) que sitúan a cualquier disolvente o soluto como un punto único en un espacio tridimensional. Este constructo, conocido como el Espacio de Hansen, transforma el problema de la solubilidad en un análisis geométrico. La distancia entre dos puntos en este espacio se convierte en una medida directa de su afinidad química: cuanto más cercanos estén, más probable es que sean miscibles.</p>
<p>3.1 Visualización Tridimensional: La Esfera de Solubilidad y el Radio de Interacción (R_0)</p>
<p>Para un soluto determinado, como un polímero o una resina, los disolventes capaces de disolverlo no se distribuyen aleatoriamente en el Espacio de Hansen, sino que se agrupan en una región bien definida. Empíricamente, se ha demostrado que esta región adopta una forma esférica. El centro de esta esfera de solubilidad corresponde a los parámetros HSP del propio soluto, y su radio se denomina Radio de Interacción (R_0) (Goetz et al., 2023). Cualquier disolvente cuyas coordenadas se encuentren dentro de esta esfera se predice como un “buen” disolvente para ese soluto.</p>
<p>3.2 Métricas Predictivas Clave: Distancia de Hansen (R_a) y Diferencia de Energía Relativa (RED)</p>
<p>Para formalizar esta relación geométrica, se utilizan dos métricas clave que permiten realizar predicciones cuantitativas.</p>
<p>La Distancia de Hansen (R_a) es la medida de la diferencia o “distancia” termodinámica entre un soluto (1) y un disolvente (2). Su cálculo se basa en la distancia euclidiana en el Espacio de Hansen, pero con una modificación crucial. Esta corrección empírica duplica el peso del componente de dispersión, reconociendo un principio fundamental de la fisicoquímica de polímeros: la compatibilidad exige primero una similitud geométrica y estérica. Las discrepancias en la forma molecular (capturadas por _D) son más difíciles de superar que las diferencias en polaridad o puentes de hidrógeno (Goetz et al., 2023).</p>
<p>Fórmula de la Distancia de Hansen (R_a): R_a = </p>
<p>A partir de R_a y R_0, se calcula la Diferencia de Energía Relativa (RED), una métrica adimensional que normaliza la distancia de un disolvente al centro de la esfera de solubilidad. El número RED es el indicador final y más práctico para predecir la solubilidad.</p>
<ul>
<li>RED &lt; 1: Alta afinidad termodinámica. El punto del disolvente se encuentra dentro de la esfera de solubilidad del soluto. Se predice una disolución completa.</li>
<li>RED = 1: Límite de la solubilidad. El punto del disolvente se encuentra exactamente en la superficie de la esfera.</li>
<li>RED &gt; 1: Baja afinidad termodinámica. El punto del disolvente está fuera de la esfera, lo que indica que es un disolvente inadecuado.</li>
</ul>
<p>Con estos fundamentos teóricos establecidos, es posible explorar cómo la teoría HSP se traduce en herramientas prácticas para la formulación y caracterización de materiales.</p>
<p>4.0 Aplicación Práctica en la Formulación y Caracterización</p>
<p>La teoría HSP trasciende el ámbito académico para proporcionar herramientas prácticas y robustas para el ingeniero de formulación y el científico de materiales. Permite ir más allá del ensayo y error, posibilitando el diseño inteligente de sistemas disolventes y la caracterización precisa de nuevos materiales. Esta sección aborda desde la creación de mezclas sinérgicas hasta la determinación de los HSP de un soluto desconocido.</p>
<p>4.1 Diseño de Mezclas de Disolventes a Medida</p>
<p>Una de las capacidades más poderosas del modelo HSP es su aplicación a mezclas de disolventes. Los parámetros de una mezcla se calculan como el promedio ponderado por el volumen de los parámetros de sus componentes individuales. Esta propiedad lineal permite una ingeniería de disolventes de alta precisión.</p>
<p>La aplicación más notable de este principio es la capacidad de crear mezclas sinérgicas. Es posible combinar dos o más líquidos que, individualmente, son malos disolventes para un soluto específico (es decir, RED &gt; 1) para formular una mezcla que sí sea un excelente disolvente (RED &lt; 1). Esto ocurre cuando los puntos HSP de los disolventes originales “flanquean” el centro de la esfera de solubilidad del soluto, y la mezcla ponderada por volumen sitúa el punto HSP de la mezcla dentro de la esfera (Goetz et al., 2023). Esta estrategia ofrece una notable flexibilidad operativa y económica para optimizar costes, seguridad y rendimiento.</p>
<p>4.2 Métodos para la Determinación de los HSP de un Soluto</p>
<p>La aplicación efectiva de la teoría requiere conocer los parámetros HSP del soluto. Cuando estos no están disponibles en la literatura, se pueden determinar mediante varios métodos establecidos:</p>
<ol type="1">
<li>Cribado Experimental (Screening): Este es el método empírico clásico. Consiste en probar la solubilidad del soluto en un conjunto estandarizado de 50 a 100 disolventes con valores HSP conocidos y bien distribuidos en el Espacio de Hansen. Los resultados (soluble/insoluble) se mapean en un software especializado que, mediante algoritmos de regresión, calcula el centro (HSP del soluto) y el radio (R_0) de la esfera que mejor separa a los buenos disolventes de los malos.</li>
<li>Métodos de Contribución de Grupo (GC): Este enfoque computacional estima los HSP a partir de la estructura química de la molécula. Se basa en el principio de que los parámetros de una molécula pueden calcularse sumando las contribuciones de sus grupos funcionales constituyentes (p.&nbsp;ej., -CH3, -OH, -C=O). Es un método rápido y conveniente que no requiere experimentos, ideal para una primera aproximación (Meng et al., 2025).</li>
<li>Cromatografía de Gases Inversa (IGC): Esta técnica analítica avanzada es especialmente útil para materiales en los que el cribado estándar es impreciso, como oligómeros, surfactantes o materiales de bajo peso molecular. En la IGC, el material desconocido se utiliza como fase estacionaria en una columna cromatográfica. Se inyectan una serie de “sondas” (disolventes con HSP conocidos) y se mide su tiempo de retención. El tiempo de retención proporciona una medida cuantitativa de la interacción termodinámica, permitiendo un cálculo muy preciso de los HSP del soluto.</li>
</ol>
<p>Estas herramientas no solo optimizan las formulaciones existentes, sino que también son fundamentales para abordar uno de los mayores desafíos de la industria química moderna: el desarrollo de soluciones sostenibles.</p>
<p>5.0 Ingeniería de Disolventes Verdes de Nueva Generación</p>
<p>La industria química se enfrenta a una presión regulatoria y social creciente para reemplazar disolventes tradicionales que son tóxicos, peligrosos o derivados de fuentes petroquímicas no renovables. Este desafío requiere un enfoque científico que vaya más allá del simple reemplazo “uno a uno”. Los Parámetros de Solubilidad de Hansen se posicionan como la herramienta cuantitativa principal para abordar esta transición de manera estratégica y eficiente, sustituyendo el ensayo y error por un diseño basado en el rendimiento molecular.</p>
<p>5.1 El Rol de los HSP en la Sustitución Estratégica de Disolventes</p>
<p>El proceso de sustitución de disolventes mediante HSP es un método sistemático y robusto. El primer paso consiste en caracterizar el sistema actual: se determinan con precisión los parámetros HSP del soluto objetivo (por ejemplo, un polímero en un recubrimiento, una resina en un adhesivo o un contaminante que debe ser eliminado). Una vez que el “objetivo” termodinámico está definido, el segundo paso es buscar en bases de datos de “disolventes verdes” —aquellos de origen biológico, con baja toxicidad, biodegradables o con un menor impacto ambiental— aquellos candidatos cuyos parámetros HSP se encuentren lo más cerca posible del soluto. El objetivo es identificar un sustituto ‘verde’ cuyo punto en el Espacio de Hansen no solo esté cerca del soluto (un R_a bajo), sino que idealmente se encuentre dentro de su esfera de interacción, resultando en un RED &lt; 1. Esto garantiza que el sustituto no es simplemente ‘parecido’, sino termodinámicamente favorable para la disolución, asegurando un reemplazo funcionalmente equivalente o superior (Munguía-López et al., 2023).</p>
<p>5.2 Mapeo de Alternativas Sostenibles: Casos de Estudio</p>
<p>La aplicación de esta metodología ha permitido identificar alternativas viables para algunos de los disolventes más problemáticos utilizados en la industria. La siguiente tabla muestra ejemplos de sustituciones potenciales guiadas por la similitud en los HSP.</p>
<p>Tabla 2: Mapeo de Sustitución de Disolventes Nocivos por Alternativas Verdes</p>
<p>Disolvente Nocivo Riesgo Primario Alternativa Verde Potencial N-Metilpirrolidona (NMP) Reprotoxicidad Mezcla optimizada de Ésteres Dibásicos (DBE) Tetrahidrofurano (THF) Formación de Peróxidos Ciclopentil Metil Éter (CPME) Tolueno Neurotoxicidad, Volátil p-Cimeno o Acetato de Soyato de Metilo</p>
<p>La viabilidad de estas sustituciones se basa en la similitud termodinámica. Por ejemplo, el Ciclopentil Metil Éter (CPME) se ha consolidado como un reemplazo eficaz del Tetrahidrofurano (THF) no solo por su perfil de seguridad superior (resistencia a la formación de peróxidos), sino porque sus coordenadas HSP son estratégicamente similares a las del THF (δD: 16.8, δP: 5.7, δH: 8.0), replicando así su comportamiento de solvencia para una amplia gama de aplicaciones. El campo de los disolventes verdes está en constante expansión, y la determinación precisa de los HSP para nuevos candidatos derivados de fuentes renovables, como los ésteres metílicos de ácidos grasos (soyato de metilo), es un paso crucial para su validación e integración industrial.</p>
<p>6.0 Conclusión: Síntesis Estratégica y Perspectivas Futuras</p>
<p>La teoría de los Parámetros de Solubilidad de Hansen representa la transición de la formulación de disolventes desde un arte empírico a una disciplina de ingeniería predictiva. Al cuantificar las interacciones intermoleculares en componentes de dispersión, polares y de puentes de hidrógeno, el modelo HSP proporciona un marco robusto y cuantitativo para predecir la compatibilidad de materiales. Su aplicación estratégica permite el diseño de mezclas de disolventes sinérgicas con un rendimiento optimizado y facilita la sustitución sistemática de compuestos peligrosos por alternativas verdes funcionalmente equivalentes, guiada por la métrica de Diferencia de Energía Relativa (RED).</p>
<p>De cara al futuro, la integración de los HSP con herramientas de modelización computacional y algoritmos de aprendizaje automático está llamada a acelerar el descubrimiento y la implementación de nuevos materiales y disolventes sostenibles. Esta sinergia permitirá realizar cribados a gran escala y optimizar formulaciones complejas con mayor rapidez y precisión, consolidando el Espacio de Hansen como una herramienta indispensable en la ciencia de materiales de nueva generación.</p>
<p>7.0 Bibliografía</p>
<p>Goetz, K. P., An, Q., Telschow, O., Hofstetter, Y. J., Schramm, T., Yangui, A., Kiligaridis, A., Loeffler, M., Taylor, A. D., Scheblykin, I. G., &amp; Vaynzof, Y. (2023). Solvent–antisolvent interactions in metal halide perovskites. Journal of Materials Chemistry C, 11(32), 10769-10787. https://doi.org/10.1039/D2TC05077C</p>
<p>Hansen, C. M. (1967). The Three Dimensional Solubility Parameter - Key to Paint Component Affinities I. Solvents, Plasticizers, Polymers, and Resins. Journal of Paint Technology, 39(505), 104-117.</p>
<p>Hansen, C. M. (2007). Hansen solubility parameters: A user’s handbook (2nd ed.). CRC Press.</p>
<p>Meng, C., Li, S., Wu, Q., Liu, J., Tang, H., &amp; Pan, M. (2025). Study on the Calculation Method of Hansen Solubility Parameters of Fuel Cell Ionomers. Polymers, 17(7), 840. https://doi.org/10.3390/polym17070840</p>
<p>Munguía-López, A. del C., Göreke, D., Sánchez-Rivera, K. L., Aguirre-Villegas, H. A., Avraamidou, S., Huber, G. W., &amp; Zavala, V. M. (2023). Large-scale computational polymer solubility predictions and applications in recycling. Green Chemistry, 25(4), 1611-1625. https://doi.org/10.1039/D3GC00404J</p>
<p>Stefanis, E., &amp; Panayiotou, C. (2008). Prediction of Hansen Solubility Parameters with a New Group-Contribution Method. International Journal of Thermophysics, 29, 568–585. https://doi.org/10.1007/s10765-008-0415-z</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>